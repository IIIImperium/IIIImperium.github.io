[{"title":"基础解题思维导图","path":"/2025/10/13/思维导图/","content":"","tags":["Recent"],"categories":["Recent"]},{"path":"/2025/10/13/ida关键/","content":"双击核对：找到变量真实值memsetinit常见于函数初始化"},{"path":"/2025/10/13/libc/","content":"title: libc库利用 延迟绑定: 在函数第一次调用后才进行绑定第一次调用后：got表被替换PLG：cod表地址got表：真实函数地址 两种攻击方式：got表劫持计算偏移得到libc基地址进行信息泄露"},{"title":"pwn部分关键点","path":"/2025/10/12/关键点捕捉/","content":"基础return system(‘binsh’) 64位：将binsh放入rdi寄存器中，后用system函数执行（站上可执行） **shift+f12找bin 2.接收及更多用法： int(io.recvline[:-1,],16) ↑↑：告诉函数转以前为16进制数3.顺序：rdirsirdxrcxr8r9 **rdi重要性高，在拼凑binsh时用ROPgadget寻找其地址 使用范例：ROPgadget –binary 名字 –only “pop|ret”pop rdi ：这条指令会从栈顶弹出一个值，并将其放入 rdi 寄存器。ret ：紧接着跳转到栈顶指定的下一个地址，从而将多个 gadget 连接起来。如何利用它来调用 system(“binsh”) ？我们的 ROP 链布局在栈上，看起来会是这样：…+—————–+ | …00000000000000| +—————–+ | address of “binsh” string | - ‘pop rdi’ 会把这个值弹入 rdi +—————–+ | address of “pop rdi ; ret” gadget | - 执行流会跳转到这里 +—————–+ | address of system function | - ‘ret’ 指令会跳转到这里 +—————–+ | …0000000000000| +—————–+","tags":["Recent"],"categories":["Recent"]},{"path":"/2025/10/12/战队其/","content":"title: 栈对齐 方法\t命令代码示例\t说明使用PWNTools ret_addr next(elf.search(asm(‘ret’))) 14\t在Python脚本中直接搜索，通常返回找到的第一个较低地址的 ret 指令。使用ROPgadget ROPgadget –binary .pwn | grep “ ret” 3\t能列出所有 ret 指令的地址，便于你选择一个合适的。使用objdump objdump -d .pwn | grep -A1 -B1 “ret” 反汇编程序并过滤出 ret 指令，可以观察其上下文。"},{"path":"/2025/10/12/pwndbg基础/","content":"title: pwndbg基础 基本用法 (启动 GDB 与 pwndbg) 安装完成后，你只需像往常一样启动 GDB，pwndbg 就会自动加载并改变 GDB 的外观和行为。 启动 GDB： 调试可执行文件： gdb 可执行文件路径 例如：gdb .a.out 附加到正在运行的进程： gdb -p 进程ID 启动后的界面：一旦 GDB 启动，pwndbg 会立即接管并显示一个全新的界面，通常包括： Code (代码区): 当前程序计数器 (PCRIPEIP) 附近的汇编代码。 Registers (寄存器区): 所有 CPU 寄存器的当前值。 Stack (栈区): 当前栈帧中的数据，包括函数参数、局部变量和返回地址。 Legend (图例): 颜色和符号的解释。 pwndbg 常用命令和功能 pwndbg 增强了 GDB 的许多功能，并添加了大量自己的命令。你仍然可以使用所有的标准 GDB 命令。 核心 GDB 命令（pwndbg 会美化其输出） r run：运行程序。 start：在 main 函数处设置断点并运行，在 main 函数入口停止。 b break ：设置断点（例如：b main, b *0x400500, b function_name, b file.c:line_number）。 c continue：继续执行直到下一个断点或程序结束。 n next：执行下一行源代码（步过函数调用）。 ni nexti：执行下一条汇编指令（步过函数调用）。 s step：执行下一行源代码（步入函数调用）。 si stepi：执行下一条汇编指令（步入函数调用）。 info b info breakpoints：查看所有断点信息。 x ：查看内存内容。 N (数量): 要显示的单位数量。 F (格式): x (十六进制), d (十进制), i (指令), s (字符串), c (字符)。 U (单位大小): b (字节), h (半字, 2字节), w (字, 4字节), g (巨字, 8字节)。 示例：x 20wx $rsp (查看栈顶 20 个 4 字节的十六进制值)。 pwndbg 特有或增强的命令 以下是 pwndbg 提供的一些最有用的命令： 上下文和显示控制 context：手动刷新并显示所有上下文信息（寄存器、栈、代码等）。 telescope tele ：以美观的格式递归地查看指针链所指向的内存内容，是 pwndbg 的明星命令之一。 例如：tele $rsp (查看栈顶内容及其指向)。 例如：tele (查看指定地址开始的 count 个 QWORD 的内容)。 hexdump [length]：以十六进制和 ASCII 形式显示内存内容。 例如：hexdump $rsp 0x40。 vmmap：显示内存映射（segments），类似于 cat procmaps。 elfheader：显示当前模块的 ELF 头信息。 main_arena：显示 malloc 的 main_arena 结构。 搜索和查找 search find ：在所有可读内存区域中搜索指定的值（字符串、整数、指针）。非常强大，可以快速定位内存中的数据。 search “my_string” search 0xdeadbeef search my_variable (搜索变量的地址) search_gdb_history：搜索 GDB 历史命令。 栈分析 stack st：显示当前栈帧的内容，通常与 context 中的栈视图一致。 retaddr：尝试定位并显示当前函数的返回地址。 canary：尝试找到并显示栈溢出保护（Canary）的值。 堆分析 heap：显示堆块（chunks）的摘要信息。 heap chunks：详细显示所有堆块的头部和数据。 heap bins：显示各种 malloc 的 bin (tcache, fastbin, smallbin, largebin) 的内容。 arena：显示 malloc_state 结构体（main_arena 或其他 arena）的详细信息。 实用工具 rop ropgadget：在当前加载的模块中搜索 ROP gadget。 ropgadget –depth (指定搜索深度)。 ropgadget –chain “; “ (尝试构建 ROP 链)。 shellcode：提供了生成各种 shellcode 的功能（如 shellcode i386linuxexecve）。 checksec：显示可执行文件的安全属性（ASLR, NX, Canary, PIE, RELRO）。 disass disassemble：反汇编函数或代码区域。 dumpargs：显示当前函数栈上的参数。 sym symbol ：查找符号的地址。 cyclic cyclic_find：用于生成和查找 Metasploit 风格的 Cyclic pattern，辅助确定栈溢出偏移。 cyclic 100 (生成一个 100 字节的模式)。 cyclic_find 0x61616161 (查找覆盖 EIPRIP 的模式值，确定偏移)。 patch：在内存中打补丁（修改字节）。 patch byte patch word patch dword patch qword patch string “new_string” 其他 dump ：将内存区域写入文件。 load ：将文件内容加载到内存。 highlight ：高亮显示某个地址的内存区域。 reset_context：重置并刷新上下文显示。 config：查看和修改 pwndbg 的配置选项。 pwndbg 常用工作流程示例 假设你正在分析一个存在栈溢出的 CTF 二进制文件 pwnme。 启动调试： gdb .pwnme pwndbg 会显示初始上下文。 查看安全属性： checksec 确认 ASLR, NX, Canary, PIE 等防护。 设置断点并运行： b *main+ # 或 b vuln_function 等r 程序在断点处停止。 查看栈和寄存器：pwndbg 自动显示。你可以滚动查看 stack 区域，或者使用 telescope $rsp 深入查看。 构造溢出数据 (如果发现栈溢出)： 生成 Cyclic pattern：cyclic 200 复制输出，并将其作为输入提供给程序：run (echo “output_from_cyclic”) 程序崩溃后，pwndbg 会显示寄存器状态，特别是 RIPEIP 的值。 查找偏移：cyclic_find RIPEIP的值，例如 cyclic_find 0x61616161。这将告诉你从输入开始到覆盖返回地址的字节数。 构造 ROP 链 (如果需要绕过 NX)： rop 或 ropgadget 命令搜索 gadgets。 利用 search 命令查找 system 函数、binsh 字符串等关键地址。 print system (GDB 命令) 可以直接获取函数地址。 内存写入和修改： 使用 patch 命令在调试时临时修改内存内容，例如 patch byte 0x400000 0x90。 使用 set $reg 修改寄存器值。 查看内存映射：vmmap 帮助你了解程序加载的模块和内存区域。 配置 pwndbg pwndbg 有许多可配置的选项，可以通过 config 命令查看和修改。 config：显示所有配置选项及其当前值。 config ：显示特定选项的详细信息。 set ：修改选项的值。 例如：set context-sections code stack reg (只显示代码、栈和寄存器)。 例如：set enable-colors off (关闭颜色)。 你也可以将常用的配置写入你的 ~.gdbinit 文件中，例如： source ~pwndbggdbinit.pyset context-sections code stack regset show-retaddr-hints off"},{"title":"C语言常见漏洞点","path":"/2025/10/12/c语言漏洞/","content":"User学习pwn所需的c语言语句基础知识 ChatGPT学习PWN所需的C语言基础知识主要包括以下几个方面: 基本数据类型和内存 char, int, long, short 等类型及其大小 有符号无符号类型(signedunsigned) 类型转换和溢出行为 理解不同架构下数据类型的大小(32位64位) 指针操作指针是PWN中最核心的概念: 指针的声明和使用(int *ptr) 指针运算(加减、解引用) 多级指针(char **argv) 函数指针及其调用 空指针和野指针 数组和字符串 数组声明和访问 数组与指针的关系 字符串操作函数:strcpy, strcat, strlen, strcmp 危险函数:gets, scanf, sprintf(无边界检查) 安全函数:strncpy, snprintf, fgets 内存管理 栈(stack)和堆(heap)的概念 动态内存分配:malloc, calloc, realloc, free 内存泄漏和double free 栈帧结构(函数调用时的内存布局) 函数相关 函数声明、定义和调用 参数传递(值传递 vs 指针传递) 返回值处理 递归函数 可变参数函数(printf家族) 结构体和联合体 struct的定义和使用 结构体指针 union的内存布局 结构体内存对齐 容易出现漏洞的语句c复制 缓冲区溢出gets(buffer); 永远不要使用scanf(“%s”, buffer); 无长度限制strcpy(dest, src); 不检查边界 格式化字符串漏洞printf(user_input); 应该用printf(“%s”, user_input) 整数溢出size_t size user_input + 10; 可能溢出malloc(size); 编译和调试相关 理解编译选项:-g(调试信息), -fno-stack-protector(关闭栈保护) 内联汇编基础 volatile关键字 系统调用和标准库 文件操作:open, read, write, close 进程操作:system, execve, fork libc函数的调用约定 位操作 按位运算符:, |, ^, ~, , 位掩码操作 大小端问题 学习建议 重点关注内存安全:理解为什么某些操作是危险的 实践编程:自己编写有漏洞的代码并尝试利用 使用调试器:熟练使用GDB查看内存和寄存器 阅读汇编:能看懂C代码编译后的汇编代码 建议从简单的栈溢出漏洞开始练习,逐步深入学习堆溢出、格式化字符串等高级漏洞类型。同时配合CTF题目进行实战练习效果更佳。 User将其的编程语句写出，并说明含义 ChatGPT好的,我将把PWN学习中常用的C语言语句写出来,并详细说明其含义和用法: 基本数据类型声明c复制 整型变量int a 10; 有符号整数(通常4字节)unsigned int b 20; 无符号整数long c 100L; 长整型(8字节在64位系统)short d 5; 短整型(2字节) 字符型char ch ‘A’; 单字符(1字节)unsigned char byte 0xFF; 常用于表示字节 查看类型大小sizeof(int); 返回int类型的字节数 指针操作c复制 指针声明和赋值int value 42;int *ptr ptr指向value的地址*ptr 100; 通过指针修改value的值 指针运算int arr[5] {1,2,3,4,5};int *p arr; 数组名就是指针p++; 指针移动到下一个元素(移动sizeof(int)字节)*(p+2); 访问arr[3] 多级指针char **argv; 指向字符指针的指针(常用于命令行参数)void *generic_ptr; 通用指针,可转换为任意类型 函数指针int (*func_ptr)(int, int); 声明函数指针func_ptr some_function; 赋值int result func_ptr(1, 2); 调用 危险的字符串函数c复制 【危险】无边界检查的函数char buffer[10]; gets(buffer); 从stdin读取,不检查长度 → 缓冲区溢出!scanf(“%s”, buffer); 同样不检查长度 → 危险!strcpy(buffer, long_string); 不检查目标缓冲区大小 → 溢出!strcat(buffer, str); 字符串拼接,不检查长度 → 危险!sprintf(buffer, “%s”, str); 格式化输出,不检查长度 → 危险! 【安全】有边界检查的替代函数fgets(buffer, sizeof(buffer), stdin); 指定最大读取长度strncpy(buffer, src, sizeof(buffer)-1); 限制复制长度snprintf(buffer, sizeof(buffer), “%s”, str); 限制输出长度 格式化字符串相关c复制 【危险】格式化字符串漏洞char user_input[100];fgets(user_input, 100, stdin);printf(user_input); 危险!用户可控制格式化字符串 如输入”%x %x %x”会泄露栈内容 【正确】做法printf(“%s”, user_input); 安全:用户输入作为参数,不是格式串 格式化说明符printf(“%d”, num); 十进制整数printf(“%x”, num); 十六进制printf(“%p”, ptr); 指针地址printf(“%s”, str); 字符串printf(“%n”, count); 将已输出字符数写入count(危险!) 内存分配函数c复制 动态分配内存int arr (int)malloc(10 * sizeof(int)); 分配40字节if(arr NULL) { 检查分配是否成功 处理错误} char str (char)calloc(100, sizeof(char)); 分配并清零 arr (int*)realloc(arr, 20 * sizeof(int)); 重新调整大小 free(arr); 释放内存arr NULL; 防止悬空指针 【危险】常见漏洞free(ptr);free(ptr); Double Free漏洞!*ptr 10; Use After Free漏洞! 数组和内存操作c复制 数组声明int arr[10]; 栈上分配int matrix[3][4]; 二维数组 数组访问arr[0] 100; 正常访问arr[15] 200; 越界访问(未定义行为,可能崩溃或被利用) 内存操作函数memset(buffer, 0, sizeof(buffer)); 将内存设置为指定值memcpy(dest, src, n); 复制n字节内存memmove(dest, src, n); 安全的内存复制(处理重叠)memcmp(buf1, buf2, n); 比较内存内容 结构体c复制 定义结构体struct Person { char name[50]; int age; char *address; 指针成员}; 使用结构体struct Person p1;p1.age 25; 访问成员strcpy(p1.name, “Alice”); struct Person *ptr ptr-age 30; 通过指针访问成员 结构体内存布局(考虑对齐)struct Data { char a; 1字节 填充3字节 int b; 4字节 char c; 1字节 填充3字节}; 总共12字节(不是6字节) 系统调用和危险函数c复制 执行系统命令system(“binsh”); 获取shell(PWN的常见目标)system(user_input); 【危险】命令注入漏洞! 进程相关execve(“binsh”, argv, envp); 执行程序fork(); 创建子进程 文件操作int fd open(“file.txt”, O_RDONLY);read(fd, buffer, size);write(fd, data, size);close(fd); 位操作c复制 位运算符int a 0x12;int b 0x34; a b; 按位与a | b; 按位或a ^ b; 按位异或~a; 按位取反a 2; 左移2位(相当于乘4)a 2; 右移2位(相当于除4) 位掩码操作int flags 0;flags | 0x01; 设置第0位flags ~0x02; 清除第1位if(flags 0x04) {} 检查第2位 条件和循环c复制 条件语句if(ptr NULL) { 空指针检查} else if(size MAX_SIZE) { 大小检查} 三元运算符int max (a b) ? a : b; 循环for(int i 0; i 10; i++) { 循环体} while(condition) { 循环体} do { 至少执行一次} while(condition); 类型转换(重要)c复制 隐式转换可能导致问题unsigned int a -1; a变成4294967295(整数溢出)int size user_input;if(size 0) {malloc(size); 如果user_input很大,可能溢出} 显式转换int x 1000;char c (char)x; 截断为-24(只保留低8位) 指针类型转换void *ptr malloc(100);int int_ptr (int)ptr; 类型转换 内联汇编(高级)c复制 在C代码中嵌入汇编asm(“nop”); 插入空操作指令 获取栈指针register long rsp asm(“rsp”);printf(“Stack pointer: %p ”, (void*)rsp); 实际PWN示例代码c复制 一个包含栈溢出漏洞的简单程序#include stdio.h#include string.h void vulnerable_function() { char buffer[64]; 64字节缓冲区 printf(“Enter your name: “); gets(buffer); 漏洞点!没有长度检查 printf(“Hello, %s! ”, buffer);} int main() { vulnerable_function(); return 0;} 利用方式:输入超过64字节的数据,覆盖返回地址 这些是PWN学习中最核心的C语言语句。建议: 实践编写:自己写包含这些漏洞的代码 调试观察:用GDB查看内存变化 逐步深入:从简单溢出到复杂利用 需要我详细解释某个具体语句或概念吗?"},{"path":"/2025/10/12/c语言基础语句/","content":"好的,我将把PWN学习中常用的C语言语句写出来,并详细说明其含义和用法: 基本数据类型声明 整型变量int a 10; 有符号整数(通常4字节)unsigned int b 20; 无符号整数long c 100L; 长整型(8字节在64位系统)short d 5; 短整型(2字节) 字符型char ch ‘A’; 单字符(1字节)unsigned char byte 0xFF; 常用于表示字节 查看类型大小sizeof(int); 返回int类型的字节数 指针操作 指针声明和赋值int value 42;int *ptr ptr指向value的地址*ptr 100; 通过指针修改value的值 指针运算int arr[5] {1,2,3,4,5};int *p arr; 数组名就是指针p++; 指针移动到下一个元素(移动sizeof(int)字节)*(p+2); 访问arr[3] 多级指针char **argv; 指向字符指针的指针(常用于命令行参数)void *generic_ptr; 通用指针,可转换为任意类型 函数指针int (*func_ptr)(int, int); 声明函数指针func_ptr some_function; 赋值int result func_ptr(1, 2); 调用 危险的字符串函数 【危险】无边界检查的函数char buffer[10]; gets(buffer); 从stdin读取,不检查长度 → 缓冲区溢出!scanf(“%s”, buffer); 同样不检查长度 → 危险!strcpy(buffer, long_string); 不检查目标缓冲区大小 → 溢出!strcat(buffer, str); 字符串拼接,不检查长度 → 危险!sprintf(buffer, “%s”, str); 格式化输出,不检查长度 → 危险! 【安全】有边界检查的替代函数fgets(buffer, sizeof(buffer), stdin); 指定最大读取长度strncpy(buffer, src, sizeof(buffer)-1); 限制复制长度snprintf(buffer, sizeof(buffer), “%s”, str); 限制输出长度 格式化字符串相关 【危险】格式化字符串漏洞char user_input[100];fgets(user_input, 100, stdin);printf(user_input); 危险!用户可控制格式化字符串 如输入”%x %x %x”会泄露栈内容 【正确】做法printf(“%s”, user_input); 安全:用户输入作为参数,不是格式串 格式化说明符printf(“%d”, num); 十进制整数printf(“%x”, num); 十六进制printf(“%p”, ptr); 指针地址printf(“%s”, str); 字符串printf(“%n”, count); 将已输出字符数写入count(危险!) 内存分配函数 动态分配内存int arr (int)malloc(10 * sizeof(int)); 分配40字节if(arr NULL) { 检查分配是否成功 处理错误} char str (char)calloc(100, sizeof(char)); 分配并清零 arr (int*)realloc(arr, 20 * sizeof(int)); 重新调整大小 free(arr); 释放内存arr NULL; 防止悬空指针 【危险】常见漏洞free(ptr);free(ptr); Double Free漏洞!*ptr 10; Use After Free漏洞! 数组和内存操作 数组声明int arr[10]; 栈上分配int matrix[3][4]; 二维数组 数组访问arr[0] 100; 正常访问arr[15] 200; 越界访问(未定义行为,可能崩溃或被利用) 内存操作函数memset(buffer, 0, sizeof(buffer)); 将内存设置为指定值memcpy(dest, src, n); 复制n字节内存memmove(dest, src, n); 安全的内存复制(处理重叠)memcmp(buf1, buf2, n); 比较内存内容 结构体 定义结构体struct Person { char name[50]; int age; char *address; 指针成员}; 使用结构体struct Person p1;p1.age 25; 访问成员strcpy(p1.name, “Alice”); struct Person *ptr ptr-age 30; 通过指针访问成员 结构体内存布局(考虑对齐)struct Data { char a; 1字节 填充3字节 int b; 4字节 char c; 1字节 填充3字节}; 总共12字节(不是6字节) 系统调用和危险函数 执行系统命令system(“binsh”); 获取shell(PWN的常见目标)system(user_input); 【危险】命令注入漏洞! 进程相关execve(“binsh”, argv, envp); 执行程序fork(); 创建子进程 文件操作int fd open(“file.txt”, O_RDONLY);read(fd, buffer, size);write(fd, data, size);close(fd); 位操作 位运算符int a 0x12;int b 0x34; a b; 按位与a | b; 按位或a ^ b; 按位异或~a; 按位取反a 2; 左移2位(相当于乘4)a 2; 右移2位(相当于除4) 位掩码操作int flags 0;flags | 0x01; 设置第0位flags ~0x02; 清除第1位if(flags 0x04) {} 检查第2位 条件和循环 条件语句if(ptr NULL) { 空指针检查} else if(size MAX_SIZE) { 大小检查} 三元运算符int max (a b) ? a : b; 循环for(int i 0; i 10; i++) { 循环体} while(condition) { 循环体} do { 至少执行一次} while(condition); 类型转换(重要) 隐式转换可能导致问题unsigned int a -1; a变成4294967295(整数溢出)int size user_input;if(size 0) {malloc(size); 如果user_input很大,可能溢出} 显式转换int x 1000;char c (char)x; 截断为-24(只保留低8位) 指针类型转换void *ptr malloc(100);int int_ptr (int)ptr; 类型转换 内联汇编(高级) 在C代码中嵌入汇编asm(“nop”); 插入空操作指令 获取栈指针register long rsp asm(“rsp”);printf(“Stack pointer: %p ”, (void*)rsp); 实际PWN示例代码 一个包含栈溢出漏洞的简单程序#include stdio.h#include string.h void vulnerable_function() { char buffer[64]; 64字节缓冲区 printf(“Enter your name: “); gets(buffer); 漏洞点!没有长度检查 printf(“Hello, %s! ”, buffer);} int main() { vulnerable_function(); return 0;} 利用方式:输入超过64字节的数据,覆盖返回地址 这些是PWN学习中最核心的C语言语句。建议: 实践编写:自己写包含这些漏洞的代码 调试观察:用GDB查看内存变化 逐步深入:从简单溢出到复杂利用 需要我详细解释某个具体语句或概念吗?"},{"title":"Hello World","path":"/2025/09/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"BLOG sample","path":"/2025/09/07/test/","content":"BLOG writting test 第一部分标记 部分多彩标记注意包括：默认 红色:red 橙色:orange 黄色:yellow 绿色:green 青色:cyan 蓝色:blue 紫色:purple 浅色:light 深色:dark 一共10种颜色。 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 壁盘样式 标签，试一试：A +D 彩签背景变色（共十色） 折叠标签默认关闭的代码折叠框 代码试验区————————————————————————– 卡片标签原地跳转！https://iiiimperium.github.io/ 选框标签这是我写的w 复制标签 分栏标签","tags":["Recent"],"categories":["Recent"]},{"title":"格式化自符串漏洞 week2","path":"/2025/09/07/格式化字符串/","content":"第一部分实战难理解点断点信息 (Breakpoint printf)：Breakpoint printf：明确指出在 printf 函数处设置了一个断点。目的： 在关键函数（例如可能存在漏洞的 printf）处暂停程序执行，以便检查其输入和内部状态。 x$rbp-0x8：这是一个 GDB 命令，用于查看 rbp-0x8 地址的内存内容。 栈视图 (0x7fffffffdba8: 0x00007fffff77c2 … 部分)：这部分是 pwndbg 栈视图的核心，通常通过 x/50xg $rsp (查看栈顶向下 50 个 8字节的十六进制值) 这样的命令触发。每一行显示一个内存地址及其对应的 8 字节（QWORD）内容。 0x61616161 是 ‘aaaa’ 的 ASCII 值，这强烈暗示用户正在尝试通过输入 aaaa 来寻找在栈上的偏移。 重要： 如果程序在读取输入后立即打印，那么栈上的布局将是：输入字符串 -> 局部变量 -> Canary -> 保存的基指针 (RBP) -> 返回地址。 在 0x7fffffffdc78 处有一个红色的 0xd712c42fdf065600。这个红色标记的 8 字节随机值非常可疑！这很可能就是栈 Canary 的值。 Canary 通常是一个 QWORD (8 字节) 随机数。 0x7fffffffdc78 - 0x7fffffffdc00 会直接执行十六进制减法，并默认以十进制显示结果（120）。hex() 函数可以将十进制整数转换回十六进制字符串表示，方便我们查看结果 0x78。 64位程序填充时加8：距离栈顶部分单独填充","tags":["Recent"],"categories":["Recent"]}]